---
layout: post
title: "redis notes"
date: 2014-10-06 16:57:18 +0800
comments: true
categories: redis
---
#Redis
最近因为项目用到了redis,想深入了解一下它的内部实现。花了一天时间看了这片[文档](http://redisbook.com/en/latest/)，下面是一些简单的学习笔记。后续打算结合源码优化一些redis占用内存高的问题。
<!--more-->
##内存数据结构

### SDS
Redis 的字符串表示为 sds ,而不是 C 字符串(以 \0 结尾的 char*)

对比 C 字符串,sds 有以下特性:

	1. 可以高效地执行长度计算(strlen);
	2. 可以高效地执行追加操作(append);
	3. 二进制安全

sds 会为追加操作进行优化:加快追加操作的速度,并降低内存分配的次数,代价是多占 用了一些内存,而且这些内存不会被主动释放。

###双端链表
Redis 实现了自己的双端链表结构。

双端链表主要有两个作用:

	1. 作为 Redis 列表类型的底层实现之一;
	2. 作为通用数据结构,被其他功能模块所使用;

双端链表及其节点的性能特性如下:

	1. 节点带有前驱和后继指针,访问前驱节点和后继节点的复杂度为 O(1) ,并且对链表 的迭代可以在从表头到表尾和从表尾到表头两个方向进行;
	2. 链表带有指向表头和表尾的指针,因此对表头和表尾进行处理的复杂度为 O(1) ;
	3. 链表带有记录节点数量的属性,所以可以在 O(1) 复杂度内返回链表的节点数量(长度);

	
###字典
字典由键值对构成的抽象数据结构。

Redis 中的数据库和哈希键都基于字典来实现。

Redis 字典的底层实现为哈希表,每个字典使用两个哈希表,一般情况下只使用 0 号哈希 表,只有在rehash 进行时,才会同时使用 0 号和 1 号哈希表。

哈希表使用链地址法来解决键冲突的问题。

Rehash 可以用于扩展或收缩哈希表。

对哈希表的 rehash 是分多次、渐进式地进行的。


###跳跃表
跳跃表是一种随机化数据结构,它的查找、添加、删除操作都可以在对数期望时间下完成。

跳跃表目前在 Redis 的唯一作用就是作为有序集类型的底层数据结构(之一,另一个构 成有序集的结构是字典)。

为了适应自身的需求,Redis 基于 William Pugh 论文中描述的跳跃表进行了修改,包括: 

	1. score 值可重复。
	2. 对比一个元素需要同时检查它的score和memeber。
	3. 每个节点带有高度为 1 层的后退指针,用于从表尾方向向表头方向迭代。

##内存映射数据结构

采用特殊编码序列，减少内存占用，占用更多CPU

###整数集合
Intset 用于有序、无重复地保存多个整数值,它会根据元素的值,自动选择该用什么长度
的整数类型来保存元素。

当一个位长度更长的整数值添加到 intset 时,需要对 intset 进行升级,新 intset 中每个 元素的位长度都等于新添加值的位长度,但原有元素的值不变。

升级会引起整个 intset 进行内存重分配,并移动集合中的所有元素,这个操作的复杂度 为 O(N) 。

Intset 只支持升级,不支持降级。

Intset 是有序的,程序使用二分查找算法来实现查找操作,复杂度为 O(lgN) 。

###压缩列表
连续的内存空间，因此insert/del都会内存拷贝，至少O(N)

ziplist 是由一系列特殊编码的内存块构成的列表,它可以保存字符数组或整数值,它还是哈希键、列表键和有序集合键的底层实现之一。

添加和删除 ziplist 节点有可能会引起连锁更新,因此,添加和删除操作的最坏复杂度为 O(N2) ,不过,因为连锁更新的出现概率并不高,所以一般可以将添加和删除操作的复 杂度视为 O(N)

##Redis 数据类型
Redis 使用自己实现的对象机制来实现类型判断、命令多态和基于引用计数的垃圾回收。

一种 Redis 类型的键可以有多种底层实现。

Redis 会预分配一些常用的数据对象,并通过共享这些对象来减少内存占用,和避免频繁 地为小对象分配内存。
``` C
/*
* Redis 对象 */
typedef struct redisObject { // 类型
unsigned type:4; // 对齐位
unsigned notused:2; // 编码方式
unsigned encoding:4;
// LRU 时间(相对于 server.lruclock)
unsigned lru:22; // 引用计数
int refcount; // 指向对象的值
void *ptr; 
} robj;

/** 对象类型 */
#define REDIS_STRING 0 // 字符串 
#define REDIS_LIST 1 // 列表
#define REDIS_SET 2 //集合
#define REDIS_ZSET 3 //有序集
#define REDIS_HASH 4// 哈希表

/*
* 对象编码 */
#define REDIS_ENCODING_RAW 0 // 编码为字符串 
#define REDIS_ENCODING_INT 1 // 编码为整数
#define REDIS_ENCODING_HT 2 // 编码为哈希表
#define REDIS_ENCODING_ZIPMAP 3 // 编码为 zipmap
#define REDIS_ENCODING_LINKEDLIST 4 // 编码为双端链表
#define REDIS_ENCODING_ZIPLIST 5 // 编码为压缩列表
#define REDIS_ENCODING_INTSET 6 // 编码为整数集合
#define REDIS_ENCODING_SKIPLIST 7 // 编码为跳跃表
```
![对象类型和对象编码](http://origin.redisbook.com/_images/graphviz-243b3a1747269b8e966a9bdd9db2129d983f2b23.svg)

###字符串
只有能表示为 long 类型的值,才会以整数的形式保存,其他类型 的整数、小数和字符串,都是用 sdshdr 结构来保存

###哈希表
创建空白哈希表时,程序默认使用 REDIS_ENCODING_ZIPLIST 编码,当以下任何一个条件被满足时,程序将编码从切换为 REDIS_ENCODING_HT :
	1. 哈希表中某个键或某个值的长度大于 server.hash_max_ziplist_value (默认值为 64)。
	2. 压缩列表中的节点数量大于server.hash_max_ziplist_entries(默认值为512)。

###集合
如果一个集合使用 REDIS_ENCODING_INTSET 编码,那么当以下任何一个条件被满足时,这个 集合会被转换成 REDIS_ENCODING_HT 编码:
	1. intset 保存的整数值个数超过 server.set_max_intset_entries (默认值为 512 )。
	2. 试图往集合里添加一个新元素,并且这个元素不能被表示为 long long 类型(也即是,它不是一个整数)。

###有序集
默认是REDIS_ENCODING_ZIPLIST，只要满足以下任一条件,就将它转换为REDIS_ENCODING_SKIPLIST 编码:
	1. ziplist 所保存的元素数量超过服务器属性 server.zset_max_ziplist_entries 的值(默认值为 128 )
	2. 新添加元素的 member 的长度大于服务器属性 server.zset_max_ziplist_value 的值(默认值为 64 )
zset 同时使用字典和跳跃表两个数据结构来保存有序集元素。

##功能的实现

###事务
事务提供了一种将多个命令打包,然后一次性、有序地执行的机制。

事务在执行过程中不会被中断,所有事务命令执行完之后,事务才能结束。

多个命令会被入队到事务队列中,然后按先进先出(FIFO)的顺序执行。

带WATCH命令的事务会将客户端和被监视的键在数据库的watched_keys字典中进行关联,当键被修改时,程序会将所有监视被修改键的客户端的 REDIS_DIRTY_CAS 选项打开。

只有在客户端的REDIS_DIRTY_CAS选项未被打开时,才能执行事务,否则事务直接返回失败。

Redis 的事务保证了 ACID 中的一致性(C)和隔离性(I),但并不保证原子性(A)和 持久性(D)。

###订阅和发布
订阅信息由服务器进程维持的redisServer.pubsub_channels字典保存,字典的键为被订阅的频道,字典的值为订阅频道的所有客户端。

当有新消息发送到频道时,程序遍历频道(键)所对应的(值)所有客户端,然后将消息 发送到所有订阅频道的客户端上。

订阅模式和订阅信息类似，不过可以用＊匹配更多

退订频道和退订模式分别是订阅频道和订阅模式的反操作
##内部机制
###数据库
数据库主要由dict和expires两个字典构成,其中dict保存键值对,而expires则保存键的过期时间。

数据库的键总是一个字符串对象,而值可以是任意一种 Redis 数据类型,包括字符串、哈希、集合、列表和有序集。

expires 的某个键和 dict 的某个键共同指向同一个字符串对象,而 expires 键的值则是该键以毫秒计算的 UNIX 过期时间戳。

Redis 使用惰性删除和定期删除两种策略来删除过期的键。

更新后的 RDB 文件和重写后的 AOF 文件都不会保留已经过期的键。

当一个过期键被删除之后,程序会追加一条新的 DEL 命令到现有 AOF 文件末尾。

当主节点删除一个过期键之后,它会显式地发送一条DEL命令到所有附属节点。

附属节点即使发现过期键,也不会自作主张地删除它,而是等待主节点发来DEL命令, 这样可以保证主节点和附属节点的数据总是一致的。

数据库的dict字典和expires字典的扩展策略和普通字典一样。它们的收缩策略是:当节点的填充百分比不足 10% 时,将可用节点数量减少至大于等于当前已用节点数量。
###RDB
rdbSave 会将数据库数据保存到 RDB 文件,并在保存完成之前阻塞调用者。

SAVE 命令直接调用 rdbSave ,阻塞 Redis 主进程;BGSAVE 用子进程调用 rdbSave ,主进程仍可继续处理命令请求。

SAVE 执行期间,AOF 写入可以在后台线程进行,BGREWRITEAOF 可以在子进程进行,所以这三种操作可以同时进行。

为了避免产生竞争条件,BGSAVE 执行时,SAVE 命令不能执行。

为了避免性能问题,BGSAVE 和 BGREWRITEAOF 不能同时执行。

调用 rdbLoad 函数载入 RDB 文件时,不能进行任何和数据库相关的操作,不过订阅与 发布方面的命令可以正常执行,因为它们和数据库不相关联。

RDB 文件的组织方式如下:
```
+-------+-------------+-----------+-----------------+-----+-----------+
| REDIS | RDB-VERSION | SELECT-DB | KEY-VALUE-PAIRS | EOF | CHECK-SUM |
+-------+-------------+-----------+-----------------+-----+-----------+
                      |<-------- DB-DATA ---------->|
```
键值对在 RDB 文件中的组织方式如下:
```
+----------------------+---------------+-----+-------+
| OPTIONAL-EXPIRE-TIME | TYPE-OF-VALUE | KEY | VALUE |
+----------------------+---------------+-----+-------+
```
RDB 文件使用不同的格式来保存不同类型的值。
##AOF
AOF 文件通过保存所有修改数据库的命令来记录数据库的状态。

AOF 文件中的所有命令都以 Redis 通讯协议的格式保存。

不同的 AOF 保存模式对数据的安全性、以及 Redis 的性能有很大的影响。
	AOF_FSYNC_NO: Write阻塞，Save阻塞，最多操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据
	AOF_FSYNC_EVERYSEC: Write阻塞，Save不阻塞，一般情况下不超过 2 秒钟的数据
	AOF_FSYNC_ALWAYS: Write阻塞，Save阻塞，最多只丢失一个命令的数据。
	
AOF 重写的目的是用更小的体积来保存数据库状态,整个重写过程基本上不影响 Redis 主进程处理命令请求。

AOF 重写是一个有歧义的名字,实际的重写工作是针对数据库的当前值来进行的,程序既不读写、也不使用原有的 AOF 文件。

AOF 可以由用户手动触发,也可以由服务器自动触发。
###事件
Redis 的事件分为时间事件(server cron job)和文件事件(client request)两类。

文件事件分为读事件和写事件两类:读事件实现了命令请求的接收,写事件实现了命令 结果的返回。

时间事件分为单次执行事件和循环执行事件,服务器常规操作serverCron就是循环事 件。

文件事件和时间事件之间是合作关系:一种事件会等待另一种事件完成之后再执行,不 会出现抢占情况。

时间事件的实际执行时间通常会比预定时间晚一些。
###服务器客户端
服务器经过初始化之后,才能开始接受命令。

服务器初始化可以分为六个步骤:
	1. 初始化服务器全局状态。 
	2. 载入配置文件。
	3. 创建 daemon 进程。
	4. 初始化服务器功能模块。 
	5. 载入数据。
	6. 开始事件循环。
服务器为每个已连接的客户端维持一个客户端结构,这个结构保存了这个客户端的所有状态信息。

客户端向服务器发送命令,服务器接受命令然后将命令传给命令执行器,执行器执行给 定命令的实现函数,执行完成之后,将结果保存在缓存,最后回传给客户端。
